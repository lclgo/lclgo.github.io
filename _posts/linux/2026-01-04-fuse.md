---
layout: post
title: "fuse基础说明"
category: GNU-linux
date: 2026-01-05 08:00:00 +0800
---

# FUSE Passthrough 技术解析文档

## 1. FUSE Passthrough 的三个阶段

FUSE Passthrough 的核心思想是将“元数据管理”与“数据 I/O”分离。其执行过程分为以下三个关键阶段：

### 第一阶段：注册阶段 (Registration) - 准备资源
*   **主体**：FUSE 守护进程 (Daemon)。
*   **动作**：
    1.  守护进程打开底层文件系统（如 Ext4）中的真实文件（Backing File），获得一个文件描述符 `fd`。
    2.  通过 `ioctl(FUSE_DEV_IOC_BACKING_OPEN)` 将此 `fd` 发送给内核。
*   **内核行为**：内核根据 `fd` 找到对应的 `struct file*` 对象，增加其引用计数，并将其存入该 FUSE 连接的“后台资源表”中，返回一个整数编号 **`backing_id`**。
*   **目的**：在内核中预先“备案”底层文件资源，使内核持有该文件的访问权。

### 第二阶段：绑定阶段 (Binding) - 建立映射
*   **主体**：内核与守护进程。
*   **动作**：
    1.  当用户进程尝试 `open()` FUSE 挂载点下的虚拟文件时，内核发送 `FUSE_OPEN` 请求给守护进程。
    2.  守护进程根据业务逻辑决定开启透传，在回复消息中设置标志位 `FOPEN_PASSTHROUGH`，并带上之前获取的 **`backing_id`**。
*   **内核行为**：内核将此次“打开操作”产生的 FUSE 文件实例与 `backing_id` 对应的底层 `struct file*` 正式关联。
*   **目的**：指明特定的虚拟文件打开实例应该走哪条“透传快车道”。

### 第三阶段：执行阶段 (Execution) - 性能加速
*   **主体**：内核 VFS 层。
*   **动作**：用户进程发起 `read()` 或 `write()`。
*   **内核行为**：内核检测到该 FUSE 文件已绑定透传，**直接调用**底层文件系统（如 Ext4）的操作函数。
*   **目的**：数据流完全绕过用户态守护进程，消除上下文切换和内存拷贝开销。

---

## 2. 理解底层文件 (Backing File) 与绑定的必要性

### 底层文件举例
*   **云盘场景**：用户看到 `/mnt/cloud/photo.jpg`（虚拟文件），实际对应的硬盘缓存是 `/home/user/.cache/data_blk_098`（底层文件）。
*   **镜像合并场景**：容器内看到 `/bin/sh`（虚拟文件），实际对应宿主机只读层 `/var/lib/docker/overlay2/l/abc/bin/sh`（底层文件）。

### 为什么注册后还需要绑定？（差异性说明）
注册只是让内核“认识”了某个底层文件，但并没有建立联系。**绑定阶段不可或缺**的原因在于：

1.  **用户视角与物理存储的差异**：
    *   **用户看到的是逻辑结构**（如 `/mnt/fuse/my_doc.docx`），这是虚拟的、动态生成的。
    *   **底层是物理结构**（如 `/data/blocks/inode_556`），这是真实的字节存储。
    *   内核并不具备“逻辑->物理”的映射账本，只有守护进程（Daemon）拥有这个账本。必须由 Daemon 在 `open` 时告诉内核：“这扇虚拟的门，后面连通的是那个具体的物理货架。”

2.  **动态策略控制**：
    *   同一个底层文件，守护进程可以对管理员开放 Passthrough 以获得最高性能，而对普通用户关闭 Passthrough 以便进行实时审计或流量监控。这种**“一人一策”**的控制必须在绑定阶段完成。

---

## 3. C 语言核心逻辑示例

以下代码展示了如何在 FUSE 守护进程中实现注册与绑定。

```c
#include <fuse_lowlevel.h>
#include <fcntl.h>
#include <sys/ioctl.h>
#include <linux/fuse.h> // 需要 Linux 6.9+ 内核头文件

/* 阶段 1：注册 (Registration) 
   通常在准备阶段或 open 回调开始时执行 */
int register_backing_file(int fuse_dev_fd, const char *real_path) {
    // 1. 守护进程打开底层真实文件
    int fd_lower = open(real_path, O_RDWR);
    if (fd_lower < 0) return -1;

    struct fuse_backing_config config = {
        .fd = fd_lower,
        .flags = 0,
    };

    // 2. 调用 ioctl 将 fd 注册给内核，换取 backing_id
    // 内核会根据 fd 找到 struct file* 并增加引用计数
    int backing_id = ioctl(fuse_dev_fd, FUSE_DEV_IOC_BACKING_OPEN, &config);

    // 注册后，守护进程可以安全关闭自己的 fd，内核已持有引用
    close(fd_lower);
    return backing_id;
}

/* 阶段 2：绑定 (Binding)
   在 FUSE 的 open 回调函数中执行 */
static void my_fuse_open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi) {
    // 假设我们要把虚拟文件映射到这个真实路径
    const char *lower_path = "/data/real_storage/file_001";

    // 执行注册
    int fuse_dev_fd = 0; // 实际开发中通过 fuse 句柄获取
    int b_id = register_backing_file(fuse_dev_fd, lower_path);

    if (b_id >= 0) {
        // --- 核心绑定动作 ---
        fi->flags |= FOPEN_PASSTHROUGH; // 告诉内核开启透传
        fi->backing_id = b_id;          // 绑定刚才注册的 ID
        
        fuse_reply_open(req, fi);
        // 此时，阶段 2 完成，两文件“合体”
    } else {
        fuse_reply_err(req, errno);
    }
}

/* 阶段 3：执行 (Execution)
   此阶段守护进程无需编写任何 read/write 代码！
   内核会自动根据绑定关系，直接操作底层文件系统的 struct file* */
```

### 总结
*   **`struct file*`**：是内核操作文件的灵魂，由守护进程通过 `open` 创建并交给内核。
*   **`backing_id`**：是内核给守护进程的凭证，代表已托管的底层资源。
*   **`FOPEN_PASSTHROUGH`**：是开关，决定了用户的一笔 I/O 是走“慢速人工通道”（守护进程）还是“快速自动通道”（内核直连）。
